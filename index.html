<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Timer</title>
    <link rel="icon" type="image/x-icon" href="icon512_rounded.png">
    <link rel="manifest" href="manifest.json" />
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 720px;
            margin: auto;
        }
        .timer {
            margin-bottom: 20px;
            padding: 20px;
            text-align: center;
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .timer-name {
            font-size: 24px;
        }
        .timer-info {
            font-size: 18px;
        }
        .logContent {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
            width: 100%;
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .log-item {
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background-color: #007bff;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .timer-block { position: relative; margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .timer-list { padding-left: 20px; }
        .sub-timer { margin-top: 5px; padding-left: 15px; border-left: 1px dotted #ccc; }
        .delete-button { position: absolute; top: 5px; right: 5px; cursor: pointer; color: red; font-weight: bold; }
        input { margin: 5px; padding: 5px; }
        button { margin: 5px; padding: 5px 10px; }
    </style>
</head>
<body>

<div class="container">
    <h1>Meeting Timer</h1>
    <div class="timer">
        <div class="timer-name"><span id="timerName">-</span></div>
        <div class="timer-description">Description: <span id="timerDescription">-</span></div>
        <div class="timer-info">Remaining Time: <span id="remainingTime">HH:MM:SS</span></div>
        <div class="timer-info">Repetitions Left: <span id="repetitionsLeft">0</span></div>
    </div>

    <div class="container" id="toHide">    
        <div>
            <label for="liberatingStructureSelect">Timer:</label>
            <select id="liberatingStructureSelect" onchange="showSelectedTimer()">
                <!--option value="" disabled selected>Select a timer</option-->
                <!-- Options will be added here dynamically -->
            </select>
            <button onclick="onclickStartTimer();">Start</button>
        </div>
        
        <br/>
    
        <div>
            <div id="timerBuilder"></div>
    
            <button onclick="saveTimer()">Save</button>
            <button onclick="displayTotalTime()">Calculate Duration</button>
    
            <div id="errorMessage" style="color: red; margin-top: 5px;"></div>
        </div>
    
        <br/>
    
    </div>
    
    <div id="timerControls" style="display: none;">        
        <button type="button" keepEnabled id="pauseResumeButton" onclick="togglePauseResume()">Pause</button>
        <button type="button" keepEnabled onclick="cancelTimer()">Next</button>
        <button type="button" keepEnabled onclick="addOneMinute()">Add 1 Minute</button>
    </div>
    
    
    <h2>Log</h2>
    <button type="button" keepEnabled onclick="clearLog()">Clear</button>
    <div class="logContent" id="logContent">
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/nosleep/0.12.0/NoSleep.min.js"></script>
<script src="utils.js"></script>
<script src="noSleepManager.js"></script>
<script src="notificationManager.js"></script>
<script src="timerDefinitions.js"></script>
<script>
    const NOTIFICATION_MANAGER = new NotificationManager();

    let globalStartTime = null; // Global variable to store the start time
    const NO_SLEEP_MANAGER = new NoSleepManager();

    // Populate the select box with options from liberatingStructures
    window.onload = function() {
        updatePredefinedTimers();
    };

    // ####### Helper Functions #######

    function updateDisplay({ name, time, repetitions }) {
        if (name !== undefined) document.getElementById("timerName").innerText = name;
        if (time !== undefined) document.getElementById("remainingTime").innerText = secondsToHMS(time);
        if (repetitions !== undefined) document.getElementById("repetitionsLeft").innerText = repetitions;
    }

    function toggleButtons(disable) {
        document.querySelectorAll("button").forEach(btn => {
            const hasKeepEnabled = btn.hasAttribute("keepEnabled");
            if (!hasKeepEnabled) {
                btn.disabled = disable;
            }
        });
    }

    function logEvent(message) {
        try {
            const logContent = document.getElementById("logContent");
            const logItem = document.createElement("div");
            const time = new Date().toLocaleTimeString();
            logItem.className = "log-item";
            logItem.innerText = `[${time}] ${message}`;
            logContent.appendChild(logItem);
            logContent.scrollTop = logContent.scrollHeight;
            console.log(message);

            // Display as a notification if permission is granted
            NOTIFICATION_MANAGER.sendNotification(message);
        } catch (error) {
            console.error("Log event failed:", error);
        }
    }

    function showAlertBox(timerName) {
        // Remove any existing alert box
        const existingAlert = document.getElementById("customAlertBox");
        if (existingAlert) existingAlert.remove();

        // Create overlay for background dim
        const overlay = document.createElement("div");
        overlay.id = "alertOverlay";
        overlay.style.position = "fixed";
        overlay.style.top = "0";
        overlay.style.left = "0";
        overlay.style.width = "100%";
        overlay.style.height = "100%";
        overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        overlay.style.display = "flex";
        overlay.style.justifyContent = "center";
        overlay.style.alignItems = "center";
        overlay.style.zIndex = "9999";

        // Create the alert box container
        const alertBox = document.createElement("div");
        alertBox.id = "customAlertBox";
        alertBox.style.backgroundColor = "#fff";
        alertBox.style.padding = "20px";
        alertBox.style.width = "300px";
        alertBox.style.borderRadius = "8px";
        alertBox.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
        alertBox.style.textAlign = "center";

        // Message content
        const message = document.createElement("p");
        message.innerText = `The timer "${timerName}" has finished!`;
        message.style.fontSize = "16px";
        message.style.marginBottom = "20px";

        // Close button
        const closeButton = document.createElement("button");
        closeButton.innerText = "Close";
        closeButton.style.padding = "10px 20px";
        closeButton.style.margin = "5px";
        closeButton.style.border = "none";
        closeButton.style.backgroundColor = "#007bff";
        closeButton.style.color = "#fff";
        closeButton.style.borderRadius = "5px";
        closeButton.style.cursor = "pointer";
        closeButton.onclick = () => {
            document.body.removeChild(overlay);
        };

        // Clean button
        const cleanButton = document.createElement("button");
        cleanButton.innerText = "Clean";
        cleanButton.style.padding = "10px 20px";
        cleanButton.style.margin = "5px";
        cleanButton.style.border = "none";
        cleanButton.style.backgroundColor = "#ff4d4d";
        cleanButton.style.color = "#fff";
        cleanButton.style.borderRadius = "5px";
        cleanButton.style.cursor = "pointer";
        cleanButton.onclick = () => {
            clearLog(); // Assumes clearLog() is defined elsewhere to clear the timer log
            updateDisplay({name:'-',time:0,repetitions:0})
            document.body.removeChild(overlay);
        };

        // Append elements to alert box and overlay
        alertBox.appendChild(message);
        alertBox.appendChild(closeButton);
        alertBox.appendChild(cleanButton);
        overlay.appendChild(alertBox);

        // Add overlay to the body
        document.body.appendChild(overlay);
    }

    // ####### Woker Setup #######

    const TIMER_WORKER = new Worker("timeWorker.js");

    TIMER_WORKER.onmessage = function(event) {
        console.log("Main: Message received from worker:", event.data);
        const { type, time, isPaused } = event.data;
        switch (type) {
            case 'updateDisplay':
                updateDisplay({ time });
                break;
            case 'togglePauseResume':
                document.getElementById("pauseResumeButton").innerText = isPaused ? "Resume" : "Pause";
                break;
            default:
                console.log("Main: Unhandled message recieved:", event.data);
        }
    };

    // ####### Button Handler #######

    async function onclickStartTimer() {
        await NOTIFICATION_MANAGER.requestNotificationPermission();
        const cleanedRoot = cleanUpTimer(rootTimer);
        startGlobalTimer();
        await startTimer(cleanedRoot);
        endGlobalTimer();
        showAlertBox(cleanedRoot.name);
    }

    function saveTimer() {
        const cleanedRoot = cleanUpTimer(rootTimer);
        const savedTimers = JSON.parse(localStorage.getItem('savedTimers')) || {};

        if (savedTimers[cleanedRoot.name]) {
            if (!confirm(`Timer '${cleanedRoot.name}' already exists. Do you want to overwrite it?`)) {
                return; // Exit if the user declines to overwrite
            }
        }

        savedTimers[cleanedRoot.name] = cleanedRoot;
        localStorage.setItem('savedTimers', JSON.stringify(savedTimers));
        updatePredefinedTimers();

        // Select the newly saved timer in the selection
        const selectBox = document.getElementById('liberatingStructureSelect');
        selectBox.value = cleanedRoot.name;
        showSelectedTimer();
    }

    function displayTotalTime() {
        const totalSeconds = calculateTotalTime(rootTimer);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        alert(`Total Duration: ${hours}h ${minutes}m ${seconds}s`);
    }

    function togglePauseResume() {
        TIMER_WORKER.postMessage({ command: 'togglePauseResume' });
    }

    function cancelTimer() {
        TIMER_WORKER.postMessage({ command: 'cancel' });
    }

    function addOneMinute() {
        TIMER_WORKER.postMessage({ command: 'addTime', seconds: 60 }); // Adds 60 seconds (1 minute)
    }

    function clearLog() {
        const logContent = document.getElementById("logContent");
        logContent.innerHTML = "";
    }

    // ####### Timer Selection #######

    function updatePredefinedTimers() {
        const selectBox = document.getElementById('liberatingStructureSelect');
        selectBox.innerHTML = ''; // Clear existing options

        // Add predefined timers from liberatingStructures
        for (const key in TIMER_DEFINITIONS) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = TIMER_DEFINITIONS[key].name;
            selectBox.appendChild(option);
        }

        // Add saved timers from local storage
        const savedTimers = JSON.parse(localStorage.getItem('savedTimers')) || {};
        for (const key in savedTimers) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = savedTimers[key].name;
            selectBox.appendChild(option);
        }
        showSelectedTimer();
    }

    // ####### Timer Functions #######

    function startGlobalTimer() {
        globalStartTime = Date.now(); // Start the global timer

        const hide = document.getElementById("toHide");
        hide.style.display = "none";
        NO_SLEEP_MANAGER.enable();

        toggleButtons(true); // Disable buttons at the start
        document.getElementById("timerControls").style.display = "block"; // Show timer controls
    }

    function endGlobalTimer() {
        if (globalStartTime !== null) {
            const elapsedTime = Math.floor((Date.now() - globalStartTime) / 1000); // Calculate elapsed time in seconds
            logEvent(`Total time elapsed: ${elapsedTime} seconds.`);
            globalStartTime = null; // Reset the global timer

            const hide = document.getElementById("toHide");
            hide.style.display = "flex";
            NO_SLEEP_MANAGER.disable();

            toggleButtons(false); // Enable buttons at the end
            document.getElementById("timerControls").style.display = "none"; // Hide timer controls
        }
    }

    async function startTimer(timer) {
        const { name, duration, repetitions, timers, groups} = timer;

        const errorMessageElement = document.getElementById("errorMessage");
        errorMessageElement.innerText = "";

        try {
            if(repetitions > 1){
                logEvent(`Starting '${name}' (${repetitions} repetitions).`);
                for (let currentRep = repetitions; currentRep > 0; currentRep--) {
                    updateDisplay({ repetitions: currentRep });
                    await startTimer({name:`${name} (${repetitions-currentRep+1}/${repetitions})`, duration, timers, groups});
                }
                return;
            }

            if(timers){
                await startSeriesOfTimers(timer)
            } else {
                await startSingleTimer(timer)
            }
        } catch (error) {
            errorMessageElement.innerText = "Please try again. " + error.message;
            console.error("JSON Parse Error:", error);
        }
    }

    async function startSingleTimer(timer) {
        const { name, duration } = timer;

        let remainingTime = hmsToSeconds(duration); // Corrected to start at full duration

        updateDisplay({ name, time: remainingTime }); // Initial display update
        logEvent(`Starting '${name}' with ${duration}.`);

        TIMER_WORKER.postMessage({ command: 'start', seconds: remainingTime });

        // Wait for the timer to complete
        await new Promise(resolve => {
            const handleMessage = (event) => {
                if (event.data.type === 'completed') {
                    TIMER_WORKER.removeEventListener('message', handleMessage);
                    resolve();
                }
            };
            TIMER_WORKER.addEventListener('message', handleMessage);
        });

        logEvent(`Timer '${name}' completed!`);
    }

    async function startSeriesOfTimers(timer) {
        const { name, timers, repetitions} = timer;
        logEvent(`Starting series '${name}'.`);
        for (let i = 0; i < timers.length; i++) {
            await startTimer(timers[i]);
        }
        logEvent(`Series '${name}' completed!`);
    }

    // ####### Custom Timer Creator #######
    let rootTimer = {
        name: "",
        duration: "00:00:00",
        timers: []
    };

    function addTimer(parent = rootTimer) {
        const timer = {
            name: "",
            duration: "",
            repetitions: "",
            timers: []
        };
        parent.duration = "";
        if(parent.timers){
            parent.timers.push(timer);
        }else{
            parent.timers = [timer];
        }
        
        renderTimers(rootTimer, document.getElementById("timerBuilder"));
    }

    function addSubTimer(timer) {
        const subTimer = {
            name: "",
            duration: "",
            repetitions: "",
            timers: []
        };
        timer.duration = "";
        if(timer.timers){
            timer.timers.push(subTimer);
        }else{
            timer.timers = [subTimer];
        }
        renderTimers(rootTimer, document.getElementById("timerBuilder"));
    }

    function deleteTimer(parent, timerIndex) {
        parent.timers.splice(timerIndex, 1);
        renderTimers(rootTimer, document.getElementById("timerBuilder"));
    }

    function renderTimers(timer, container, parent = null, index = null) {
        container.innerHTML = "";
        const mainDiv = document.createElement("div");
        mainDiv.className = "timer-block";

        // "×" delete button for each timer
        if (parent !== null && index !== null) {
            const deleteButton = document.createElement("span");
            deleteButton.className = "delete-button";
            deleteButton.innerText = "×";
            deleteButton.onclick = () => deleteTimer(parent, index);
            mainDiv.appendChild(deleteButton);
        }

        // Timer name input
        const nameInput = document.createElement("input");
        nameInput.placeholder = "Name";
        nameInput.value = timer.name || "";
        nameInput.required = true;
        nameInput.oninput = (e) => (timer.name = e.target.value);

        // Duration input
        const durationInput = document.createElement("input");
        durationInput.placeholder = "Duration HH:MM:SS";
        durationInput.value = timer.duration || "";
        durationInput.oninput = (e) => (timer.duration = e.target.value);
        durationInput.disabled = timer.timers && timer.timers.length > 0;

        // Repetitions input
        const repetitionsInput = document.createElement("input");
        repetitionsInput.placeholder = "Repetitions";
        repetitionsInput.type = "number";
        repetitionsInput.value = timer.repetitions || "";
        repetitionsInput.min = 2;
        repetitionsInput.oninput = (e) => (timer.repetitions = e.target.value);

        mainDiv.append(nameInput, durationInput, repetitionsInput);
    
        // List of sub-timers
        const timerList = document.createElement("div");
        timerList.className = "timer-list";
        if (timer.timers) {
            timer.timers.forEach((subTimer, subIndex) => {
                const subTimerContainer = document.createElement("div");
                subTimerContainer.className = "sub-timer";
                renderTimers(subTimer, subTimerContainer, timer, subIndex);
                timerList.appendChild(subTimerContainer);
            });
        }
        mainDiv.appendChild(timerList);

        // Add sub-timer button
        const addSubTimerButton = document.createElement("button");
        addSubTimerButton.innerText = "+";
        addSubTimerButton.onclick = () => timer !== rootTimer ? addSubTimer(timer) : addTimer();
        mainDiv.appendChild(addSubTimerButton);

        if (timer.timers && timer.timers.length > 0) {
            // Collapse/Expand button for sub-timers
            const toggleButton = document.createElement("button");
            toggleButton.innerText = "Hide";
            toggleButton.onclick = () => {
                timerList.style.display = timerList.style.display === "none" ? "block" : "none";
                toggleButton.innerText = timerList.style.display === "none" ? "Show" : "Hide";
            };
            mainDiv.appendChild(toggleButton);
        }

        container.appendChild(mainDiv);
    }

    function cleanUpTimer(timer) {
        const cleanedTimer = { name: timer.name };

        if (timer.duration && timer.timers && timer.timers.length > 0) {
            console.log(`${timer.name} cannot have both duration and sub-timers together`);
            delete timer.duration;
        }
        if (timer.duration) cleanedTimer.duration = timer.duration;
        if (timer.repetitions && timer.repetitions > 1) cleanedTimer.repetitions = timer.repetitions;

        if (timer.timers && timer.timers.length > 0) {
            cleanedTimer.timers = timer.timers.map(cleanUpTimer);
        }

        return cleanedTimer;
    }

    function showSelectedTimer() {
        const selectBox = document.getElementById('liberatingStructureSelect');
        const selectedStructureKey = selectBox.value;
        const selectedStructure = TIMER_DEFINITIONS[selectedStructureKey] || JSON.parse(localStorage.getItem('savedTimers'))[selectedStructureKey];
        const errorMessageElement = document.getElementById("errorMessage");

        try {
            if (selectedStructure && selectedStructure.timer) {
                rootTimer = selectedStructure.timer;
            } else {
                rootTimer = selectedStructure;
            }
            renderTimers(rootTimer, document.getElementById("timerBuilder"));
            errorMessageElement.innerText = ""; // Clear any previous error message
        } catch (error) {
            errorMessageElement.innerText = "Invalid JSON structure. Please try again. " + error.message;
            console.error("JSON Parse Error:", error);
        }
    }

    function parseDuration(duration) {
        if(typeof duration === 'number'){
            return duration;
        }
        const parts = duration.split(':').map(Number); // Convert each part to a number
        let totalSeconds = 0;

        if (parts.length === 3) {
            // HH:MM:SS format
            const [hours, minutes, seconds] = parts;
            totalSeconds = hours * 3600 + minutes * 60 + seconds;
        } else if (parts.length === 2) {
            // MM:SS format
            const [minutes, seconds] = parts;
            totalSeconds = minutes * 60 + seconds;
        } else if (parts.length === 1) {
            // SS format
            totalSeconds = parts[0];
        }

        return totalSeconds;
    }

    function calculateTotalTime(timer) {
        let totalTime = 0;

        // Parse the timer's duration and convert to seconds, defaulting to 0 if empty
        const durationInSeconds = timer.duration ? parseDuration(timer.duration) : 0;
        
        // Multiply by repetitions, defaulting to 1 if repetitions is not set or invalid
        const repetitions = timer.repetitions && timer.repetitions > 1 ? timer.repetitions : 1;
        totalTime += durationInSeconds * repetitions;

        // Recursively add time for each sub-timer
        if (Array.isArray(timer.timers) && timer.timers.length > 0) {
            timer.timers.forEach(subTimer => {
                totalTime += calculateTotalTime(subTimer) * repetitions;
            });
        }

        return totalTime;
    }

    // Initialize root timer UI
    renderTimers(rootTimer, document.getElementById("timerBuilder"));
</script>

</body>
</html>

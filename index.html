<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meeting Timer</title>
    <link rel="icon" type="image/x-icon" href="icon512_rounded.png">
    <link rel="manifest" href="manifest.json" />
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 720px;
            margin: auto;
        }
        .timer {
            margin-bottom: 20px;
            padding: 20px;
            text-align: center;
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .timer-name {
            font-size: 24px;
        }
        .timer-info {
            font-size: 18px;
        }
        .logContent {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: scroll;
            border: 1px solid #ccc;
            padding: 10px;
            width: 100%;
            background-color: #f9f9f9;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .log-item {
            margin-bottom: 5px;
            font-size: 14px;
            color: #555;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            background-color: #007bff;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .timer-block { position: relative; margin: 10px 0; padding: 10px; border: 1px solid #ccc; }
        .timer-list { padding-left: 20px; }
        .sub-timer { margin-top: 5px; padding-left: 15px; border-left: 1px dotted #ccc; }
        .delete-button { position: absolute; top: 5px; right: 5px; cursor: pointer; color: red; font-weight: bold; }
        input { margin: 5px; padding: 5px; }
        button { margin: 5px; padding: 5px 10px; }
    </style>
</head>
<body>

<div class="container">
    <h1>Meeting Timer</h1>
    <div class="timer">
        <div class="timer-name"><span id="timerName">-</span></div>
        <div class="timer-description">Description: <span id="timerDescription">-</span></div>
        <div class="timer-info">Remaining Time: <span id="remainingTime">HH:MM:SS</span></div>
        <div class="timer-info">Repetitions Left: <span id="repetitionsLeft">0</span></div>
    </div>

    <div class="container" id="toHide">    
        <div>
            <label for="liberatingStructureSelect">Timer:</label>
            <select id="liberatingStructureSelect" onchange="showSelectedTimer()">
                <!--option value="" disabled selected>Select a timer</option-->
                <!-- Options will be added here dynamically -->
            </select>
            <button onclick="onclickStartTimer();">Start</button>
        </div>
        
        <br/>
    
        <div>
            <div id="timerBuilder"></div>
    
            <button onclick="saveTimer()">Save</button>
            <button onclick="displayTotalTime()">Calculate Duration</button>
    
            <div id="errorMessage" style="color: red; margin-top: 5px;"></div>
        </div>
    
        <br/>
    
    </div>
    
    <div id="timerControls" style="display: none;">        
        <button type="button" keepEnabled id="pauseResumeButton" onclick="togglePauseResume()">Pause</button>
        <button type="button" keepEnabled onclick="cancelTimer()">Next</button>
        <button type="button" keepEnabled onclick="addOneMinute()">Add 1 Minute</button>
    </div>
    
    
    <h2>Log</h2>
    <button type="button" keepEnabled onclick="clearLog()">Clear</button>
    <div class="logContent" id="logContent">
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/nosleep/0.12.0/NoSleep.min.js"></script>
<script src="utils.js"></script>
<script src="noSleepManager.js"></script>
<script>
    const liberatingStructures={
        "Countdown":{ 
            name:"Countdown",
            description:'',
            timer:{ name: 'Countdown', duration: '5:00'}
        },
        "Wicket Questions":{ 
            name:"Wicked Questions",
            description:'"Wicked Questions" is a Liberating Structure designed to surface and explore paradoxes that groups face when navigating complex challenges. This structure helps reveal the “both/and” thinking necessary for innovation and avoids simplistic “either/or” responses. By articulating paradoxical forces influencing behavior, teams can engage in strategic thinking that confronts messy realities, sparks creativity, and balances competing needs.',
            timer:{name:"Wicked Questions",
                timers: [
                    { name: 'Introduce the concept', duration: '5:00'},
                    { name: 'Each participant generates pairs of paradoxes', duration: '5:00'},
                    { name: 'Each group selects its most impactful', duration: '1:00'},
                    { name: 'Selected Wicked Questions are shared with the whole group', duration: '5:00'},
                    { name: 'Whole group picks out the most powerful ones and further refines the Wicked Questions.', duration: '10:00'},
            ]}
        },
        "1-2-4-All":{
            name:"1-2-4-All",
            description: '"1-2-4-All" engages everyone in generating ideas by first reflecting individually, then discussing in pairs, then groups of four, and finally as a whole group. It encourages widespread contribution and converges on key ideas quickly.',
            timer:{
                name: "1-2-4-All",
                timers: [
                    { name: 'Individual reflection', duration: '1:00' },
                    { name: 'Pair discussion', duration: '2:00' },
                    { name: 'Share with foursome', duration: '4:00' },
                    { name: 'Group discussion', duration: '5:00' }
                ]
            }
        },
        "TRIZ": {
            name: "TRIZ",
            description: '"TRIZ" is a problem-solving Liberating Structure that uses reverse brainstorming. Participants imagine ways to achieve the worst possible outcome and then identify how these pitfalls might be avoided or reversed.',
            timer: {
                name: "TRIZ",
                timers: [
                    { name: 'Identify the worst outcome imaginable', duration: '5:00' },
                    { name: 'Brainstorm ways to achieve that outcome', duration: '5:00' },
                    { name: 'Reflect on how current practices might be contributing', duration: '3:00' },
                    { name: 'Plan actions to avoid those pitfalls', duration: '5:00' }
                ]
            }
        },
        "Impromptu Networking": {
            name: "Impromptu Networking",
            description: '"Impromptu Networking" encourages participants to meet new people and share ideas rapidly. It’s designed to quickly get everyone’s ideas into the room and energize participants at the start of a session.',
            timer: {
                name: "Impromptu Networking",
                timers: [
                    { name: 'Introduce concept and instructions', duration: '2:00' },
                    { name: 'Round 1: Pair up and discuss', duration: '3:00' },
                    { name: 'Round 2: Switch partners and discuss', duration: '3:00' },
                    { name: 'Round 3: Switch partners again and discuss', duration: '3:00' }
                ]
            }
        },
        "Nine Whys": {
            name: "Nine Whys",
            description: '"Nine Whys" helps participants explore the deeper purpose behind their work. By asking "why" repeatedly, they uncover fundamental motivations and underlying assumptions, fostering a stronger sense of purpose.',
            timer: {
                name: "Nine Whys",
                timers: [
                    { name: 'Introduce the concept', duration: '2:00' },
                    { name: 'Participants pair up and ask each other "why"', duration: '4:00' },
                    { name: 'Switch roles and repeat', duration: '4:00' },
                    { name: 'Whole group sharing of insights', duration: '5:00' }
                ]
            }
        },
        "25/10 Crowdsourcing": {
            name: "25/10 Crowdsourcing",
            description: '"25/10 Crowdsourcing" helps identify the most popular ideas among a group quickly. Ideas are generated individually and then scored by others through multiple rounds of scoring, which reveals top ideas.',
            timer: {
                name: "25/10 Crowdsourcing",
                timers: [
                    { name: 'Generate ideas individually', duration: '5:00' },
                    { name: 'Scoring round 1', duration: '2:00' },
                    { name: 'Scoring round 2', duration: '2:00' },
                    { name: 'Scoring round 3', duration: '2:00' },
                    { name: 'Announce top ideas', duration: '2:00' }
                ]
            }
        },
        "What, So What, Now What?": {
            name: "What, So What, Now What?",
            description: '"What, So What, Now What?" guides groups through reflective questions to process experiences, identify insights, and plan actionable steps forward. This structure is helpful for debriefing activities and projects.',
            timer: {
                name: "What, So What, Now What?",
                timers: [
                    { name: 'Reflection on "What?" (What happened?)', duration: '3:00' },
                    { name: 'Discussion on "So What?" (What does it mean?)', duration: '4:00' },
                    { name: 'Planning on "Now What?" (What next?)', duration: '5:00' }
                ]
            }
        },
        "Appreciative Interviews": {
            name: "Appreciative Interviews",
            description: '"Appreciative Interviews" invites participants to share their personal successes and strengths, creating a positive foundation for group discussions and future actions. It strengthens relationships by exploring meaningful personal stories.',
            timer: {
                name: "Appreciative Interviews",
                timers: [
                    { name: 'Introduce the activity and goals', duration: '3:00' },
                    { name: 'Participants pair up and interview each other', duration: '7:00' },
                    { name: 'Switch roles and repeat', duration: '7:00' },
                    { name: 'Whole group shares highlights', duration: '5:00' }
                ]
            }
        },
        "Celebrity Interview": {
            name: "Celebrity Interview",
            description: '"Celebrity Interview" uses a panel format to spotlight an expert or “celebrity” who is interviewed by the group. This structure allows for in-depth exploration of specific knowledge or experiences in a lively and engaging way.',
            timer: {
                name: "Celebrity Interview",
                timers: [
                    { name: 'Setup and explain process', duration: '3:00' },
                    { name: 'Celebrity shares their insights', duration: '5:00' },
                    { name: 'Open for audience questions', duration: '10:00' },
                    { name: 'Reflections and takeaways', duration: '5:00' }
                ]
            }
        },
        "Shift and Share": {
            name: "Shift and Share",
            description: '"Shift and Share" enables group members to present their ideas, projects, or skills in small rotating groups, giving everyone a chance to showcase their work and gain diverse feedback efficiently.',
            timer: {
                name: "Shift and Share",
                timers: [
                    { name: 'Setup and instructions', duration: '3:00' },
                    { name: 'Presenter 1 shares and receives feedback', duration: '5:00' },
                    { name: 'Presenter 2 shares and receives feedback', duration: '5:00' },
                    { name: 'Presenter 3 shares and receives feedback', duration: '5:00' },
                    { name: 'Whole group reflections', duration: '5:00' }
                ]
            }
        },
        "Min Specs": {
            name: "Min Specs",
            description: '"Min Specs" helps teams identify the minimum requirements for a successful outcome, enabling them to eliminate unnecessary work and focus on essential elements.',
            timer: {
                name: "Min Specs",
                timers: [
                    { name: 'Introduce the concept', duration: '3:00' },
                    { name: 'Identify essential success criteria', duration: '5:00' },
                    { name: 'Discuss and refine criteria in small groups', duration: '5:00' },
                    { name: 'Share refined criteria with the whole group', duration: '5:00' }
                ]
            }
        },
        "Drawing Together": {
            name: "Drawing Together",
            description: '"Drawing Together" encourages groups to collaboratively create a visual representation of their ideas or plans, making abstract ideas concrete and fostering collective ownership of the outcome.',
            timer: {
                name: "Drawing Together",
                timers: [
                    { name: 'Explain concept and objectives', duration: '3:00' },
                    { name: 'Individuals start sketches', duration: '5:00' },
                    { name: 'Small groups combine and refine sketches', duration: '7:00' },
                    { name: 'Whole group shares final drawings', duration: '5:00' }
                ]
            }
        },
        "Purpose to Practice": {
            name: "Purpose to Practice",
            description: '"Purpose to Practice" helps groups design and plan initiatives by aligning on purpose, principles, participants, structure, and practices. It provides a comprehensive roadmap for collaborative action.',
            timer: {
                name: "Purpose to Practice",
                timers: [
                    { name: 'Define purpose', duration: '5:00' },
                    { name: 'Identify guiding principles', duration: '5:00' },
                    { name: 'List key participants and their roles', duration: '5:00' },
                    { name: 'Outline structure and key actions', duration: '5:00' },
                    { name: 'Develop initial practices', duration: '5:00' }
                ]
            }
        },
        "User Experience Fishbowl": {
            name: "User Experience Fishbowl",
            description: '"User Experience Fishbowl" allows participants to observe real users as they interact with a product or process, gaining valuable insights into usability and user needs through direct observation and guided reflection.',
            timer: {
                name: "User Experience Fishbowl",
                timers: [
                    { name: 'Set up fishbowl seating', duration: '3:00' },
                    { name: 'User demonstration of product/process', duration: '10:00' },
                    { name: 'Observers take notes and reflect', duration: '5:00' },
                    { name: 'Group shares observations and insights', duration: '7:00' }
                ]
            }
        },
        "Mad Tea": {
            name: "Mad Tea",
            description: '"Mad Tea" is a high-energy structured conversation that enables participants to quickly exchange ideas and viewpoints by responding to prompts in rotating pairs. It encourages fast-paced engagement and fresh perspectives.',
            timer: {
                name: "Mad Tea",
                timers: [
                    { name: 'Introduce the activity and form pairs', duration: '3:00' },
                    { name: 'Round 1: Respond to prompt', duration: '1:00' },
                    { name: 'Round 2: Switch partners and respond to prompt', duration: '1:00' },
                    { name: 'Round 3: Switch partners and respond to prompt', duration: '1:00' },
                    { name: 'Group debrief and highlight key insights', duration: '5:00' }
                ]
            }
        },
        "Conversation Café": {
            name: "Conversation Café",
            description: '"Conversation Café" provides a space for open, meaningful discussions on complex topics. Using structured rounds, it encourages deep listening, shared understanding, and collective insight.',
            timer: {
                name: "Conversation Café",
                timers: [
                    { name: 'Round 1: Introduce topic and set ground rules', duration: '3:00' },
                    { name: 'Round 2: Open sharing in rounds', duration: '10:00' },
                    { name: 'Round 3: Group discusses emerging themes', duration: '7:00' },
                    { name: 'Reflection and takeaway round', duration: '5:00' }
                ]
            }
        },
        "Treuka Consulting": {
            name: "Treuka Consulting",
            description: 'The Treuka Consulting method is a structured, collaborative approach designed to help clients clarify key objectives, identify core challenges, co-create solutions, and define actionable steps. This process aims to ensure a deep understanding of the client’s needs, deliver tailored advice, and support effective implementation strategies.',
            timer: {
                name: "Treuka Consulting",
                timers: [
                    { name: 'Invite participants to think of a question they would like to ask as a client.', duration: '1:00' },
                    {
                        name: "Client Triads",
                        repetitions: 3,
                        timers: [
                            { name: 'Client poses their question to the group.', duration: '3:00' },
                            { name: 'Consultants ask clarifying questions to the client.', duration: '3:00' },
                            { name: 'Client turns around, facing away from the consultants.', duration: '1:00' },
                            { name: 'Consultants discuss and develop ideas, suggestions, and advice.', duration: '5:00' },
                            { name: 'Client turns back to the group and shares what they found most valuable from the experience.', duration: '2:00' },
                            { name: 'Group moves to the next client and repeats the steps.', duration: '10:00' },
                        ]
                    }
                ]
            }
        },
        "Pomodoro Technique": {
            name: "Pomodoro Technique",
            description: 'The Pomodoro Technique is a time management method that encourages focused work sessions followed by short breaks. Each session is called a "Pomodoro," lasting typically 25 minutes, with a 5-minute break afterward. After completing four Pomodoros, a longer break is taken. This method enhances productivity and helps maintain concentration.',
            timer: {
                name: "Pomodoro Technique",
                timers: [
                    { name: 'Work Session 1', duration: '25:00' },
                    { name: 'Short Break 1', duration: '5:00' },
                    { name: 'Work Session 2', duration: '25:00' },
                    { name: 'Short Break 2', duration: '5:00' },
                    { name: 'Work Session 3', duration: '25:00' },
                    { name: 'Short Break 3', duration: '5:00' },
                    { name: 'Work Session 4', duration: '25:00' },
                    { name: 'Long Break', duration: '15:00' }
                ]
            }
        }
    }

    let globalStartTime = null; // Global variable to store the start time
    let notificationEnabled = false; // Track notification permission status
    const noSleepManager = new NoSleepManager();

    // Populate the select box with options from liberatingStructures
    window.onload = function() {
        updatePredefinedTimers();
    };

    // ####### Helper Functions #######

    function updateDisplay({ name, time, repetitions }) {
        if (name !== undefined) document.getElementById("timerName").innerText = name;
        if (time !== undefined) document.getElementById("remainingTime").innerText = secondsToHMS(time);
        if (repetitions !== undefined) document.getElementById("repetitionsLeft").innerText = repetitions;
    }

    function toggleButtons(disable) {
        document.querySelectorAll("button").forEach(btn => {
            const hasKeepEnabled = btn.hasAttribute("keepEnabled");
            if (!hasKeepEnabled) {
                btn.disabled = disable;
            }
        });
    }

    function logEvent(message) {
        try {
            const logContent = document.getElementById("logContent");
            const logItem = document.createElement("div");
            const time = new Date().toLocaleTimeString();
            logItem.className = "log-item";
            logItem.innerText = `[${time}] ${message}`;
            logContent.appendChild(logItem);
            logContent.scrollTop = logContent.scrollHeight;
            console.log(message);

            // Display as a notification if permission is granted
            if (notificationEnabled && "Notification" in window) {
                new Notification(message);
            }
        } catch (error) {
            console.error("Log event failed:", error);
        }
    }

    function showAlertBox(timerName) {
        // Remove any existing alert box
        const existingAlert = document.getElementById("customAlertBox");
        if (existingAlert) existingAlert.remove();

        // Create overlay for background dim
        const overlay = document.createElement("div");
        overlay.id = "alertOverlay";
        overlay.style.position = "fixed";
        overlay.style.top = "0";
        overlay.style.left = "0";
        overlay.style.width = "100%";
        overlay.style.height = "100%";
        overlay.style.backgroundColor = "rgba(0, 0, 0, 0.5)";
        overlay.style.display = "flex";
        overlay.style.justifyContent = "center";
        overlay.style.alignItems = "center";
        overlay.style.zIndex = "9999";

        // Create the alert box container
        const alertBox = document.createElement("div");
        alertBox.id = "customAlertBox";
        alertBox.style.backgroundColor = "#fff";
        alertBox.style.padding = "20px";
        alertBox.style.width = "300px";
        alertBox.style.borderRadius = "8px";
        alertBox.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.2)";
        alertBox.style.textAlign = "center";

        // Message content
        const message = document.createElement("p");
        message.innerText = `The timer "${timerName}" has finished!`;
        message.style.fontSize = "16px";
        message.style.marginBottom = "20px";

        // Close button
        const closeButton = document.createElement("button");
        closeButton.innerText = "Close";
        closeButton.style.padding = "10px 20px";
        closeButton.style.margin = "5px";
        closeButton.style.border = "none";
        closeButton.style.backgroundColor = "#007bff";
        closeButton.style.color = "#fff";
        closeButton.style.borderRadius = "5px";
        closeButton.style.cursor = "pointer";
        closeButton.onclick = () => {
            document.body.removeChild(overlay);
        };

        // Clean button
        const cleanButton = document.createElement("button");
        cleanButton.innerText = "Clean";
        cleanButton.style.padding = "10px 20px";
        cleanButton.style.margin = "5px";
        cleanButton.style.border = "none";
        cleanButton.style.backgroundColor = "#ff4d4d";
        cleanButton.style.color = "#fff";
        cleanButton.style.borderRadius = "5px";
        cleanButton.style.cursor = "pointer";
        cleanButton.onclick = () => {
            clearLog(); // Assumes clearLog() is defined elsewhere to clear the timer log
            updateDisplay({name:'-',time:0,repetitions:0})
            document.body.removeChild(overlay);
        };

        // Append elements to alert box and overlay
        alertBox.appendChild(message);
        alertBox.appendChild(closeButton);
        alertBox.appendChild(cleanButton);
        overlay.appendChild(alertBox);

        // Add overlay to the body
        document.body.appendChild(overlay);
    }

    // ####### Woker Setup #######

    const TIMER_WORKER = new Worker("timeWorker.js");

    TIMER_WORKER.onmessage = function(event) {
        console.log("Main: Message received from worker:", event.data);
        const { type, time, isPaused } = event.data;
        switch (type) {
            case 'updateDisplay':
                updateDisplay({ time });
                break;
            case 'togglePauseResume':
                document.getElementById("pauseResumeButton").innerText = isPaused ? "Resume" : "Pause";
                break;
            default:
                console.log("Main: Unhandled message recieved:", event.data);
        }
    };

    // Functions to be called from onclick attributes
    function startTimer() {
        TIMER_WORKER.postMessage({ command: 'start', seconds: 10 });  // Starts a 10-second timer
    }

    function cancelTimer() {
        TIMER_WORKER.postMessage({ command: 'cancel' });
    }

    function addOneMinute() {
        TIMER_WORKER.postMessage({ command: 'addTime', seconds: 60 }); // Adds 60 seconds (1 minute)
    }

    function togglePauseResume() {
        TIMER_WORKER.postMessage({ command: 'togglePauseResume' });
    }

    // ####### Button Handler #######

    async function onclickStartTimer() {
        await requestNotificationPermission();
        const cleanedRoot = cleanUpTimer(rootTimer);
        startGlobalTimer();
        await startTimer(cleanedRoot);
        endGlobalTimer();
        showAlertBox(cleanedRoot.name);
    }

    function saveTimer() {
        const cleanedRoot = cleanUpTimer(rootTimer);
        const savedTimers = JSON.parse(localStorage.getItem('savedTimers')) || {};

        if (savedTimers[cleanedRoot.name]) {
            if (!confirm(`Timer '${cleanedRoot.name}' already exists. Do you want to overwrite it?`)) {
                return; // Exit if the user declines to overwrite
            }
        }

        savedTimers[cleanedRoot.name] = cleanedRoot;
        localStorage.setItem('savedTimers', JSON.stringify(savedTimers));
        updatePredefinedTimers();

        // Select the newly saved timer in the selection
        const selectBox = document.getElementById('liberatingStructureSelect');
        selectBox.value = cleanedRoot.name;
        showSelectedTimer();
    }

    function updatePredefinedTimers() {
        const selectBox = document.getElementById('liberatingStructureSelect');
        selectBox.innerHTML = ''; // Clear existing options

        // Add predefined timers from liberatingStructures
        for (const key in liberatingStructures) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = liberatingStructures[key].name;
            selectBox.appendChild(option);
        }

        // Add saved timers from local storage
        const savedTimers = JSON.parse(localStorage.getItem('savedTimers')) || {};
        for (const key in savedTimers) {
            const option = document.createElement('option');
            option.value = key;
            option.textContent = savedTimers[key].name;
            selectBox.appendChild(option);
        }
        showSelectedTimer();
    }

    async function requestNotificationPermission() {
        if (!("Notification" in window)) {
            console.log("This browser does not support notifications.");
            return;
        }
        if (Notification.permission === "granted") {
            notificationEnabled = true;
        } else if (Notification.permission !== "denied") {
            const permission = await Notification.requestPermission();
            notificationEnabled = permission === "granted";
        }
    }

    function clearLog() {
        const logContent = document.getElementById("logContent");
        logContent.innerHTML = "";
    }

    // ####### Timer Functions #######

    function startGlobalTimer() {
        globalStartTime = Date.now(); // Start the global timer

        const hide = document.getElementById("toHide");
        hide.style.display = "none";
        noSleepManager.enable();

        toggleButtons(true); // Disable buttons at the start
        document.getElementById("timerControls").style.display = "block"; // Show timer controls
    }

    function endGlobalTimer() {
        if (globalStartTime !== null) {
            const elapsedTime = Math.floor((Date.now() - globalStartTime) / 1000); // Calculate elapsed time in seconds
            logEvent(`Total time elapsed: ${elapsedTime} seconds.`);
            globalStartTime = null; // Reset the global timer

            const hide = document.getElementById("toHide");
            hide.style.display = "flex";
            noSleepManager.disable();

            toggleButtons(false); // Enable buttons at the end
            document.getElementById("timerControls").style.display = "none"; // Hide timer controls
        }
    }

    async function startTimer(timer) {
        const { name, duration, repetitions, timers, groups} = timer;

        const errorMessageElement = document.getElementById("errorMessage");
        errorMessageElement.innerText = "";

        try {
            if(repetitions > 1){
                logEvent(`Starting '${name}' (${repetitions} repetitions).`);
                for (let currentRep = repetitions; currentRep > 0; currentRep--) {
                    updateDisplay({ repetitions: currentRep });
                    await startTimer({name:`${name} (${repetitions-currentRep+1}/${repetitions})`, duration, timers, groups});
                }
                return;
            }

            if(timers){
                await startSeriesOfTimers(timer)
            } else {
                await startSingleTimer(timer)
            }
        } catch (error) {
            errorMessageElement.innerText = "Please try again. " + error.message;
            console.error("JSON Parse Error:", error);
        }
    }

    async function startSingleTimer(timer) {
        const { name, duration } = timer;

        let remainingTime = hmsToSeconds(duration); // Corrected to start at full duration

        updateDisplay({ name, time: remainingTime }); // Initial display update
        logEvent(`Starting '${name}' with ${duration}.`);

        TIMER_WORKER.postMessage({ command: 'start', seconds: remainingTime });

        // Wait for the timer to complete
        await new Promise(resolve => {
            const handleMessage = (event) => {
                if (event.data.type === 'completed') {
                    TIMER_WORKER.removeEventListener('message', handleMessage);
                    resolve();
                }
            };
            TIMER_WORKER.addEventListener('message', handleMessage);
        });

        logEvent(`Timer '${name}' completed!`);
    }

    async function startSeriesOfTimers(timer) {
        const { name, timers, repetitions} = timer;
        logEvent(`Starting series '${name}'.`);
        for (let i = 0; i < timers.length; i++) {
            await startTimer(timers[i]);
        }
        logEvent(`Series '${name}' completed!`);
    }

    // ####### Custom Timer Creator #######
    let rootTimer = {
        name: "",
        duration: "00:00:00",
        timers: []
    };

    function addTimer(parent = rootTimer) {
        const timer = {
            name: "",
            duration: "",
            repetitions: "",
            timers: []
        };
        parent.duration = "";
        if(parent.timers){
            parent.timers.push(timer);
        }else{
            parent.timers = [timer];
        }
        
        renderTimers(rootTimer, document.getElementById("timerBuilder"));
    }

    function addSubTimer(timer) {
        const subTimer = {
            name: "",
            duration: "",
            repetitions: "",
            timers: []
        };
        timer.duration = "";
        if(timer.timers){
            timer.timers.push(subTimer);
        }else{
            timer.timers = [subTimer];
        }
        renderTimers(rootTimer, document.getElementById("timerBuilder"));
    }

    function deleteTimer(parent, timerIndex) {
        parent.timers.splice(timerIndex, 1);
        renderTimers(rootTimer, document.getElementById("timerBuilder"));
    }

    function renderTimers(timer, container, parent = null, index = null) {
        container.innerHTML = "";
        const mainDiv = document.createElement("div");
        mainDiv.className = "timer-block";

        // "×" delete button for each timer
        if (parent !== null && index !== null) {
            const deleteButton = document.createElement("span");
            deleteButton.className = "delete-button";
            deleteButton.innerText = "×";
            deleteButton.onclick = () => deleteTimer(parent, index);
            mainDiv.appendChild(deleteButton);
        }

        // Timer name input
        const nameInput = document.createElement("input");
        nameInput.placeholder = "Name";
        nameInput.value = timer.name || "";
        nameInput.required = true;
        nameInput.oninput = (e) => (timer.name = e.target.value);

        // Duration input
        const durationInput = document.createElement("input");
        durationInput.placeholder = "Duration HH:MM:SS";
        durationInput.value = timer.duration || "";
        durationInput.oninput = (e) => (timer.duration = e.target.value);
        durationInput.disabled = timer.timers && timer.timers.length > 0;

        // Repetitions input
        const repetitionsInput = document.createElement("input");
        repetitionsInput.placeholder = "Repetitions";
        repetitionsInput.type = "number";
        repetitionsInput.value = timer.repetitions || "";
        repetitionsInput.min = 2;
        repetitionsInput.oninput = (e) => (timer.repetitions = e.target.value);

        mainDiv.append(nameInput, durationInput, repetitionsInput);
    
        // List of sub-timers
        const timerList = document.createElement("div");
        timerList.className = "timer-list";
        if (timer.timers) {
            timer.timers.forEach((subTimer, subIndex) => {
                const subTimerContainer = document.createElement("div");
                subTimerContainer.className = "sub-timer";
                renderTimers(subTimer, subTimerContainer, timer, subIndex);
                timerList.appendChild(subTimerContainer);
            });
        }
        mainDiv.appendChild(timerList);

        // Add sub-timer button
        const addSubTimerButton = document.createElement("button");
        addSubTimerButton.innerText = "+";
        addSubTimerButton.onclick = () => timer !== rootTimer ? addSubTimer(timer) : addTimer();
        mainDiv.appendChild(addSubTimerButton);

        if (timer.timers && timer.timers.length > 0) {
            // Collapse/Expand button for sub-timers
            const toggleButton = document.createElement("button");
            toggleButton.innerText = "Hide";
            toggleButton.onclick = () => {
                timerList.style.display = timerList.style.display === "none" ? "block" : "none";
                toggleButton.innerText = timerList.style.display === "none" ? "Show" : "Hide";
            };
            mainDiv.appendChild(toggleButton);
        }

        container.appendChild(mainDiv);
    }

    function cleanUpTimer(timer) {
        const cleanedTimer = { name: timer.name };

        if (timer.duration && timer.timers && timer.timers.length > 0) {
            console.log(`${timer.name} cannot have both duration and sub-timers together`);
            delete timer.duration;
        }
        if (timer.duration) cleanedTimer.duration = timer.duration;
        if (timer.repetitions && timer.repetitions > 1) cleanedTimer.repetitions = timer.repetitions;

        if (timer.timers && timer.timers.length > 0) {
            cleanedTimer.timers = timer.timers.map(cleanUpTimer);
        }

        return cleanedTimer;
    }

    function showSelectedTimer() {
        const selectBox = document.getElementById('liberatingStructureSelect');
        const selectedStructureKey = selectBox.value;
        const selectedStructure = liberatingStructures[selectedStructureKey] || JSON.parse(localStorage.getItem('savedTimers'))[selectedStructureKey];
        const errorMessageElement = document.getElementById("errorMessage");

        try {
            if (selectedStructure && selectedStructure.timer) {
                rootTimer = selectedStructure.timer;
            } else {
                rootTimer = selectedStructure;
            }
            renderTimers(rootTimer, document.getElementById("timerBuilder"));
            errorMessageElement.innerText = ""; // Clear any previous error message
        } catch (error) {
            errorMessageElement.innerText = "Invalid JSON structure. Please try again. " + error.message;
            console.error("JSON Parse Error:", error);
        }
    }

    function parseDuration(duration) {
        if(typeof duration === 'number'){
            return duration;
        }
        const parts = duration.split(':').map(Number); // Convert each part to a number
        let totalSeconds = 0;

        if (parts.length === 3) {
            // HH:MM:SS format
            const [hours, minutes, seconds] = parts;
            totalSeconds = hours * 3600 + minutes * 60 + seconds;
        } else if (parts.length === 2) {
            // MM:SS format
            const [minutes, seconds] = parts;
            totalSeconds = minutes * 60 + seconds;
        } else if (parts.length === 1) {
            // SS format
            totalSeconds = parts[0];
        }

        return totalSeconds;
    }

    function calculateTotalTime(timer) {
        let totalTime = 0;

        // Parse the timer's duration and convert to seconds, defaulting to 0 if empty
        const durationInSeconds = timer.duration ? parseDuration(timer.duration) : 0;
        
        // Multiply by repetitions, defaulting to 1 if repetitions is not set or invalid
        const repetitions = timer.repetitions && timer.repetitions > 1 ? timer.repetitions : 1;
        totalTime += durationInSeconds * repetitions;

        // Recursively add time for each sub-timer
        if (Array.isArray(timer.timers) && timer.timers.length > 0) {
            timer.timers.forEach(subTimer => {
                totalTime += calculateTotalTime(subTimer) * repetitions;
            });
        }

        return totalTime;
    }

    function displayTotalTime() {
        const totalSeconds = calculateTotalTime(rootTimer);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        alert(`Total Duration: ${hours}h ${minutes}m ${seconds}s`);
    }

    // Initialize root timer UI
    renderTimers(rootTimer, document.getElementById("timerBuilder"));
</script>

</body>
</html>
